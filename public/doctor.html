<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ğŸ‘¨â€âš•ï¸ Doctor Video Console</title>
  <style>
    body{margin:0;background:#0f0f10;color:#e8e8ea;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Inter,"Helvetica Neue",Arial}
    .wrap{max-width:1100px;margin:28px auto;padding:0 16px}
    h1{font-weight:700;text-align:center;margin:8px 0 18px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:22px}
    video{width:100%;height:380px;background:#000;border:1px solid #3b3b3f;border-radius:10px;object-fit:cover}
    .btns{display:flex;gap:12px;margin:18px 0}
    button{padding:10px 18px;border-radius:10px;border:0;font-weight:700;cursor:pointer}
    .ok{background:#0fa36b;color:#fff}
    .warn{background:#e55252;color:#fff}
    .ok[disabled],.warn[disabled]{opacity:.45;cursor:not-allowed}
    pre{background:#111214;border:1px solid #2a2b2f;border-radius:10px;color:#b9bcc6;
        padding:10px;height:160px;overflow:auto;font-size:12px;line-height:1.5}
    .small{opacity:.85;font-size:12px;text-align:center;margin-top:6px}
  </style>
</head>
<body>
<div class="wrap">
  <h1>ğŸ‘¨â€âš•ï¸ Doctor Video Console</h1>

  <div class="grid">
    <video id="local"  autoplay muted playsinline></video>
    <video id="remote" autoplay        playsinline></video>
  </div>

  <div class="btns">
    <button id="answerBtn" class="ok"   disabled>æ¥å¬</button>
    <button id="hangupBtn" class="warn" disabled>æŒ‚æ–­</button>
  </div>

  <pre id="log"></pre>
  <div class="small">WS ä¸ WebRTC éƒ½åœ¨æœ¬é¡µå®Œæˆã€‚è‹¥é¢„è§ˆé»‘å±ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨çš„ç›¸æœº/éº¦å…‹é£æƒé™ã€‚</div>
</div>

<script>
(async () => {
  // === å¯é€‰ï¼šè‡ªåŠ¨æ¥å¬ï¼ˆtrue=è‡ªåŠ¨æ¥å¬ï¼Œfalse=éœ€ç‚¹å‡»â€œæ¥å¬â€ï¼‰ ===
  const AUTO_ANSWER = false;

  const $local  = document.getElementById('local');
  const $remote = document.getElementById('remote');
  const $answer = document.getElementById('answerBtn');
  const $hangup = document.getElementById('hangupBtn');
  const $log    = document.getElementById('log');

  const log = (...args) => {
    const line = args.map(x => (typeof x === 'string' ? x : JSON.stringify(x))).join(' ');
    $log.textContent += line + '\n';
    $log.scrollTop = $log.scrollHeight;
    console.log('[Doctor]', ...args);
  };

  // ---- WebSocket ----
  const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws';
  const ws = new WebSocket(wsUrl);

  // ---- WebRTC ----
  let pc;
  let localStream;
  let haveOffer = null;               // ä¿å­˜æ”¶åˆ°çš„ offerï¼ˆå»¶åæ¥å¬ï¼‰
  const pendingCandidates = [];       // åœ¨ setRemoteDescription ä¹‹å‰æš‚å­˜ ICE

  function mkPC(){
    const _pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    _pc.onicecandidate = (e) => {
      if (!e.candidate) return;
      wsSend({
        type: 'signal',
        from: 'doctor',
        to:   'parent',
        payload: {
          type: 'candidate',
          candidate: e.candidate.candidate,
          sdpMid: e.candidate.sdpMid,
          sdpMLineIndex: e.candidate.sdpMLineIndex
        }
      });
      log('ğŸ“® Sent ICE Candidate');
    };

    _pc.ontrack = (ev) => {
      if ($remote.srcObject !== ev.streams[0]) {
        $remote.srcObject = ev.streams[0];
        $remote.play().catch(()=>{});
        log('ğŸ“º Remote track received');
      }
    };

    return _pc;
  }

  async function startLocalMedia() {
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      $local.srcObject = localStream;
      await $local.play().catch(()=>{});
      log('ğŸ¥ Local stream ready, waiting for Offerâ€¦');
    } catch (err) {
      log('âš ï¸ Camera/mic access denied:', err.message || err);
    }
  }

  async function ensurePC() {
    if (pc) return pc;
    pc = mkPC();
    if (!localStream) await startLocalMedia();
    for (const track of localStream.getTracks()) {
      pc.addTrack(track, localStream);
    }
    $hangup.disabled = false;
    return pc;
  }

  async function acceptOffer(offer) {
    const pc = await ensurePC();
    const desc = { type: 'offer', sdp: offer.sdp };
    await pc.setRemoteDescription(desc);
    log('âœ… setRemoteDescription(offer)');

    while (pendingCandidates.length) {
      const c = pendingCandidates.shift();
      try { await pc.addIceCandidate(c); } catch (e) { log('âš ï¸ addQueuedCandidate error:', e.message || e); }
    }

    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    wsSend({
      type: 'signal',
      from: 'doctor',
      to:   'parent',
      payload: { type: 'answer', sdp: answer.sdp }
    });
    log('ğŸ“® Answer sent to parent');
  }

  async function addRemoteCandidate(payload) {
    const candInit = {
      candidate: payload.candidate,
      sdpMid: payload.sdpMid,
      sdpMLineIndex: payload.sdpMLineIndex
    };
    if (!pc || !pc.remoteDescription) {
      pendingCandidates.push(candInit);
      return;
    }
    try {
      await pc.addIceCandidate(candInit);
      log('âœ… ICE Candidate added');
    } catch (e) {
      log('âš ï¸ addIceCandidate error:', e.message || e);
    }
  }

  function wsSend(obj) {
    try {
      if (ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(obj));
    } catch (e) {
      log('âš ï¸ WS send error:', e.message || e);
    }
  }

  // ---- UI ----
  $answer.onclick = async () => {
    if (!haveOffer) return;
    $answer.disabled = true;
    await acceptOffer(haveOffer);
    haveOffer = null;
  };

  $hangup.onclick = () => {
    try { pc && pc.close(); } catch {}
    pc = null;
    $hangup.disabled = true;
    $answer.disabled = true;
    wsSend({ type: 'signal', from:'doctor', to:'parent', payload:{ type:'hangup' }});
    log('ğŸ§¹ Call ended');
  };

  // ---- WS äº‹ä»¶ ----
  ws.onopen = async () => {
    log(`ğŸ”Œ WS connected: ${wsUrl}`);
    wsSend({ type:'register', id:'doctor' });
    await startLocalMedia();
  };

  ws.onmessage = async (ev) => {
    let msg;
    try { msg = JSON.parse(ev.data); } catch { return; }

    // âœ… å…¼å®¹ä¸¤ç§é£æ ¼ï¼š1) åŒ…äº† payload çš„ signalï¼›2) ç›´æ¥ offer/candidate
    if (msg.type === 'signal') {
      const p = msg.payload || {};
      if (p.type === 'offer' || p.sdp) {
        haveOffer = { type: 'offer', sdp: p.sdp || p.offer?.sdp };
        log('ğŸ“¥ Offer received from parent');
        if (AUTO_ANSWER) { await acceptOffer(haveOffer); haveOffer = null; }
        else { $answer.disabled = false; log('ğŸ‘‰ ç‚¹å‡» [æ¥å¬] å¼€å§‹é€šè¯'); }
      } else if (p.type === 'candidate' && p.candidate) {
        await addRemoteCandidate(p);
      } else if (p.type === 'hangup') {
        $hangup.click();
      }
      return;
    }

    // âœ… è€æ ¼å¼ï¼šç›´æ¥ä¸‹å‘
    if (msg.type === 'offer' || msg.sdp) {
      haveOffer = { type: 'offer', sdp: msg.sdp || msg.offer?.sdp };
      log('ğŸ“¥ Offer received (legacy)');
      if (AUTO_ANSWER) { await acceptOffer(haveOffer); haveOffer = null; }
      else { $answer.disabled = false; log('ğŸ‘‰ ç‚¹å‡» [æ¥å¬] å¼€å§‹é€šè¯'); }
    } else if (msg.type === 'candidate') {
      await addRemoteCandidate(msg);
    }
  };

  ws.onclose = () => log('ğŸ§¯ WS closed');
})();
</script>
</body>
</html>
