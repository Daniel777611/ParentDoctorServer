<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1"
  />
  <title>Doctor Video Console</title>
  <style>
    :root { color-scheme: light dark; }
    body { margin:0; background:#111; color:#eee; font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial; }
    h1 { text-align:center; font-weight:700; padding:20px 10px; }
    .wrap { max-width:1200px; margin:0 auto; padding:16px; }
    .grid {
      display:grid; grid-template-columns:1fr 1fr; gap:24px; align-items:center;
    }
    video {
      width:100%; height:420px; background:#000; border:2px solid #666; border-radius:10px; object-fit:cover;
    }
    .btns { display:flex; gap:12px; margin-top:16px; }
    button {
      padding:12px 18px; border-radius:10px; border:none; cursor:pointer; font-size:16px; font-weight:700;
    }
    .accept { background:#239b56; color:#fff; }
    .hangup { background:#d32f2f; color:#fff; }
    .log { margin-top:14px; background:#0d0d0d; border:1px solid #333; border-radius:8px; padding:12px; height:160px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; }
    .muted { opacity:.7 }
  </style>
</head>
<body>
  <h1>ğŸ§‘â€âš•ï¸ Doctor Video Console</h1>

  <div class="wrap">
    <div class="grid">
      <div>
        <video id="local" autoplay playsinline muted class="muted"></video>
      </div>
      <div>
        <video id="remote" autoplay playsinline></video>
      </div>
    </div>

    <div class="btns">
      <button id="accept" class="accept" disabled>æ¥å¬</button>
      <button id="hangup" class="hangup" disabled>æŒ‚æ–­</button>
    </div>

    <div id="log" class="log"></div>
  </div>

<script>
(() => {
  /** ---------- åŸºç¡€ ---------- */
  const logBox = document.getElementById('log');
  const log = (...args) => {
    const line = args.map(x => (typeof x === 'string' ? x : JSON.stringify(x))).join(' ');
    const p = document.createElement('div');
    p.textContent = line;
    logBox.appendChild(p);
    logBox.scrollTop = logBox.scrollHeight;
    console.log('[doctor]', ...args);
  };

  const localVideo = document.getElementById('local');
  const remoteVideo = document.getElementById('remote');
  const btnAccept = document.getElementById('accept');
  const btnHangup = document.getElementById('hangup');

  const wsURL = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws';
  const myId = 'doctor';             // åŒ»ç”Ÿç«¯å›ºå®š ID
  const parentId = 'parent';         // iOS ç«¯å›ºå®š IDï¼ˆä¸ App é‡Œä¿æŒä¸€è‡´ï¼‰

  /** ---------- WebSocket ---------- */
  let ws;
  let pc;
  let localStream;

  function wsSend(obj) {
    ws?.send(JSON.stringify(obj));
  }

  function ensurePC() {
    if (pc) return pc;

    const cfg = {
      iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }]
    };
    pc = new RTCPeerConnection(cfg);

    pc.onicecandidate = (ev) => {
      if (ev.candidate) {
        wsSend({
          type: 'signal',
          from: myId,
          to: parentId,
          payload: {
            candidate: ev.candidate.candidate,
            sdpMLineIndex: ev.candidate.sdpMLineIndex,
            sdpMid: ev.candidate.sdpMid
          }
        });
      }
    };

    pc.ontrack = (ev) => {
      log('ğŸ“¥ ontrack:', ev.track.kind);
      // è¿œç«¯è§†é¢‘/éŸ³é¢‘ track
      if (ev.streams && ev.streams[0]) {
        remoteVideo.srcObject = ev.streams[0];
      } else {
        // Fallbackï¼šç»„è£… MediaStream
        const ms = new MediaStream();
        ms.addTrack(ev.track);
        remoteVideo.srcObject = ms;
      }
    };

    pc.onconnectionstatechange = () => log('ğŸ”— pc state =', pc.connectionState);
    pc.onsignalingstatechange = () => log('ğŸ—‚ signaling =', pc.signalingState);
    return pc;
  }

  async function openLocal() {
    if (localStream) return localStream;
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    localVideo.srcObject = localStream;

    const pc = ensurePC();
    // Unified Plan: addTrack
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    return localStream;
  }

  async function handleOffer(offer) {
    await openLocal();
    const pc = ensurePC();

    await pc.setRemoteDescription(new RTCSessionDescription(offer));
    log('âœ… setRemoteDescription(offer) done');

    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    log('âœ… createAnswer + setLocalDescription done');

    wsSend({
      type: 'signal',
      from: myId,
      to: parentId,
      payload: { type: 'answer', sdp: answer.sdp }
    });

    btnHangup.disabled = false;
  }

  function handleCandidate(payload) {
    const ice = new RTCIceCandidate({
      candidate: payload.candidate,
      sdpMLineIndex: payload.sdpMLineIndex,
      sdpMid: payload.sdpMid
    });
    ensurePC().addIceCandidate(ice).catch(e => log('addIceCandidate error:', e));
  }

  function hangup() {
    if (pc) {
      pc.getSenders().forEach(s => s.track && s.track.stop());
      pc.getReceivers().forEach(r => r.track && r.track.stop());
      pc.close();
    }
    pc = null;
    remoteVideo.srcObject = null;
    btnHangup.disabled = true;
    log('ğŸ‘‹ hangup');
  }

  /** ---------- äº‹ä»¶ ---------- */
  btnAccept.onclick = async () => {
    btnAccept.disabled = true;    // ç‚¹å‡»åç­‰ Offer ä¸‹å‘ï¼Œé€šè¿‡ WS æ”¶åˆ° Offer æ‰ä¼šç»§ç»­
    await openLocal();
    log('âœ… Local stream ready, waiting for Offer...');
  };

  btnHangup.onclick = hangup;

  /** ---------- è¿æ¥ WS ---------- */
  ws = new WebSocket(wsURL);
  ws.onopen = () => {
    log('ğŸ”Œ WS connected:', wsURL);
    wsSend({ type: 'register', id: myId });
    btnAccept.disabled = false;
  };
  ws.onclose = () => log('ğŸ”Œ WS closed');
  ws.onerror = (e) => log('âŒ WS error', e);

  ws.onmessage = async (ev) => {
    let msg;
    try { msg = JSON.parse(ev.data); } catch { return; }
    if (msg.type !== 'signal' || msg.to !== myId) return;

    const p = msg.payload || {};
    if (p.type === 'offer') {
      log('ğŸ“¨ offer received');
      await handleOffer({ type: 'offer', sdp: p.sdp });
    } else if (p.type === 'answer') {
      // ä¸€èˆ¬åŒ»ç”Ÿç«¯ä¸ä¼šæ”¶åˆ° answerï¼Œè¿™é‡Œä¿ç•™ä»¥ä¾¿äº’æ‹¨
      log('ğŸ“¨ answer (ignored on doctor)');
    } else if (p.candidate) {
      handleCandidate(p);
    }
  };
})();
</script>
</body>
</html>
